generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum NotificationType {
  EMAIL
  PUSH
}

enum TimeUnit {
  MINUTES
  HOURS
  DAYS
}

model File {
  id              Int      @id @default(autoincrement())
  filename        String   @db.VarChar(255)
  initialFilename String   @db.VarChar(255)
  path            String   @db.VarChar(255)
  uri             String   @db.VarChar(255)
  linkImage       Link[]   @relation("link_image")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now())
}

model User {
  id                  Int                 @id @default(autoincrement())
  email               String              @unique @db.VarChar(255)
  password            String?             @db.VarChar(255)
  firstName           String?             @db.VarChar(255)
  lastName            String?             @db.VarChar(255)
  lastLoginDate       DateTime
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @default(now()) @updatedAt
  sessions            Session[]
  notes               Note[]
  notebooks           Notebook[]
  linkGroups          LinkGroup[]
  links               Link[]
  tasks               Task[]
  comments            Comment[]
  collaborations      NoteCollaboration[]
  invitationsSent     Invitation[]        @relation("InvitationsSent")
  invitationsReceived Invitation[]        @relation("InvitationsReceived")

  events                 Event[]
  eventsShared           EventSharedWithMember[]
  resetTokens            ResetToken[]
  linkClicks             LinkClick[]
  searchHistory          SearchHistory[]
  scores                 Score[]
  noteTasks              NoteTask[]
  meeting                Meeting[]
  devices                DeviceToken[]
  notificationPreference NotificationPreference?

  AutoInstruction            AutoInstruction[]
  DailyTask                  DailyTask[]
  DailyPlan                  DailyPlan[]
  DailyTaskHistory           DailyTaskHistory[]
  meetingInvitationsSent     MeetingInvitation[] @relation("MeetingInvitationsSent")
  meetingInvitationsReceived MeetingInvitation[] @relation("MeetingInvitationsReceived")
}

enum CalendarEventType {
  TASK
  EVENT // Event can materialize a meeting too
}

enum LocationType {
  DISTANCE
  ONSITE
}

enum Recurrence {
  NONE
  DAILY
  WEEKLY
  MONTHLY
  ANNUAL
}

enum PermissionLevel {
  READ
  WRITE
  ADMIN
}

enum Level {
  EASY
  MEDIUM
  HARD
}

model User {
  id                     Int                     @id @default(autoincrement())
  email                  String                  @unique @db.VarChar(255)
  password               String?                 @db.VarChar(255)
  firstName              String?                 @db.VarChar(255)
  lastName               String?                 @db.VarChar(255)
  lastLoginDate          DateTime
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @default(now()) @updatedAt
  sessions               Session[]
  notes                  Note[]
  notebooks              Notebook[]
  linkGroups             LinkGroup[]
  links                  Link[]
  // TODO: Delete tasks, events, meetings ‚ùå
  tasks                  Task[]
  comments               Comment[]
  collaborations         NoteCollaboration[]
  invitationsSent        Invitation[]            @relation("InvitationsSent")
  invitationsReceived    Invitation[]            @relation("InvitationsReceived")
  // TODO: Delete tasks, events, meetings ‚ùå
  events                 Event[]
  eventsShared           EventSharedWithMember[]
  resetTokens            ResetToken[]
  linkClicks             LinkClick[]
  searchHistory          SearchHistory[]
  scores                 Score[]
  noteTasks              NoteTask[]
  // TODO: Delete tasks, events, meetings ‚ùå
  meeting                Meeting[]
  devices                DeviceToken[]
  notificationPreference NotificationPreference?
  AutoInstruction        AutoInstruction[]
  calendarEvents         CalendarEvent[]
}

// NOTE: EVENTS ############################################################################
model CalendarEvent {
  id                       Int                     @id @default(autoincrement())
  type                     CalendarEventType
  // Mandatory fields, common to both types
  title                    String
  description              String?
  startDate                DateTime                @default(now())
  endDate                  DateTime                @default(dbgenerated("(NOW() + INTERVAL 15 MINUTE)"))
  createdAt                DateTime                @default(now())
  updatedAt                DateTime                @default(now()) @updatedAt
  token                    String?                 @unique
  userId                   Int
  user                     User                    @relation(fields: [userId], references: [id])
  notificationSent         Boolean                 @default(false)
  notificationPreferenceId Int?
  notificationPreference   NotificationPreference? @relation(fields: [notificationPreferenceId], references: [id])
  // From google sync
  googleEventId            String?                 @unique
  isRecurring              Boolean?                @default(false)
  recurrence               Recurrence              @default(NONE)
  completed                Boolean?                @default(false)
  location                 LocationType?
  place                    String?
  link                     String?
}

// TODO: Refactor notification preference type : instead of creating a new model, just use an array of NotificationType ü§¶
model NotificationPreference {
  id             Int                          @id @default(autoincrement())
  userId         Int                          @unique
  user           User                         @relation(fields: [userId], references: [id])
  types          NotificationPreferenceType[]
  timeBefore     Int
  timeUnit       TimeUnit
  createdAt      DateTime                     @default(now())
  updatedAt      DateTime                     @default(now()) @updatedAt
  // TODO: Delete tasks, events, meetings ‚ùå
  tasks          Task[]
  events         Event[]
  meetings       Meeting[]
  calendarEvents CalendarEvent[]
}

// TODO: After the above refactor, delete this model ‚ùå
model NotificationPreferenceType {
  id                       Int                    @id @default(autoincrement())
  type                     NotificationType
  notificationPreferenceId Int
  notificationPreference   NotificationPreference @relation(fields: [notificationPreferenceId], references: [id], onDelete: Cascade)
  createdAt                DateTime               @default(now())
  updatedAt                DateTime               @default(now()) @updatedAt
}

// NOTE: NOTES ############################################################################
model Note {
  id             Int                 @id @default(autoincrement())
  title          String
  content        String?             @db.LongText
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  userId         Int
  notebookId     Int?
  user           User                @relation(fields: [userId], references: [id])
  notebook       Notebook?           @relation(fields: [notebookId], references: [id])
  collaborations NoteCollaboration[]
  tags           Tag[]               @relation("NoteTags")
  comments       Comment[]           @relation("NoteComments")
  notetasks      NoteTask[]          @relation("NoteTasks")
}

model Notebook {
  id     Int    @id @default(autoincrement())
  title  String
  userId Int
  user   User   @relation(fields: [userId], references: [id])
  notes  Note[]
}

model NoteCollaboration {
  id              Int             @id @default(autoincrement())
  permissionLevel PermissionLevel
  noteId          Int
  userId          Int
  note            Note            @relation(fields: [noteId], references: [id])
  user            User            @relation(fields: [userId], references: [id])
}

model NoteTask {
  id        Int        @id @default(autoincrement())
  title     String
  completed Boolean    @default(false)
  noteId    Int
  userId    Int
  parentId  Int?
  note      Note       @relation(fields: [noteId], references: [id], name: "NoteTasks", onDelete: Cascade)
  user      User       @relation(fields: [userId], references: [id])
  parent    NoteTask?  @relation("NoteTaskRelation", fields: [parentId], references: [id], onDelete: Cascade)
  subtasks  NoteTask[] @relation("NoteTaskRelation")
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  notes Note[] @relation("NoteTags")
}

model File {
  id              Int      @id @default(autoincrement())
  filename        String   @db.VarChar(255)
  initialFilename String   @db.VarChar(255)
  path            String   @db.VarChar(255)
  uri             String   @db.VarChar(255)
  linkImage       Link[]   @relation("link_image")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now())
}

// NOTE: LINKS ############################################################################
model LinkGroup {
  id          Int     @id @default(autoincrement())
  name        String
  description String?
  userId      Int
  user        User    @relation(fields: [userId], references: [id])
  links       Link[]
}

model Link {
  id          Int         @id @default(autoincrement())
  name        String
  url         String      @db.Text
  description String?
  linkGroupId Int
  userId      Int
  linkGroup   LinkGroup   @relation(fields: [linkGroupId], references: [id])
  user        User        @relation(fields: [userId], references: [id])
  clicks      LinkClick[]
  imageId     Int?
  image       File?       @relation("link_image", fields: [imageId], references: [id])
}

model LinkClick {
  id     Int   @id @default(autoincrement())
  clicks Int   @default(0)
  linkId Int?
  userId Int?
  link   Link? @relation(fields: [linkId], references: [id])
  user   User? @relation(fields: [userId], references: [id])
}

// TODO: Delete ‚ùå
model Task {
  id                       Int                     @id @default(autoincrement())
  title                    String
  description              String
  dueDate                  DateTime?
  completed                Boolean                 @default(false)
  userId                   Int
  user                     User                    @relation(fields: [userId], references: [id])
  notificationPreferenceId Int?
  notificationPreference   NotificationPreference? @relation(fields: [notificationPreferenceId], references: [id])
  notificationSent         Boolean?                @default(false)
  token                    String?                 @unique
}

model Invitation {
  id                         Int     @id @default(autoincrement())
  receiverId                 Int?
  senderId                   Int
  receiver                   User?   @relation("InvitationsReceived", fields: [receiverId], references: [id])
  sender                     User    @relation("InvitationsSent", fields: [senderId], references: [id])
  externalEmailInvitation    String?
  tokenForExternalInvitation String?
  isExternal                 Boolean @default(false)
  isRelation                 Boolean @default(false)
}

// TODO: Delete ‚ùå
model Event {
  id                       Int                     @id @default(autoincrement())
  title                    String
  description              String
  startDate                DateTime
  endDate                  DateTime
  isRecurring              Boolean?                @default(false)
  recurrence               Recurrence?             @default(NONE)
  location                 String
  place                    String?
  link                     String?
  createdAt                DateTime                @default(now())
  updatedAt                DateTime                @default(now()) @updatedAt
  userId                   Int
  user                     User                    @relation(fields: [userId], references: [id])
  sharedWith               EventSharedWithMember[]
  notificationPreferenceId Int?
  notificationPreference   NotificationPreference? @relation(fields: [notificationPreferenceId], references: [id])
  notificationSent         Boolean?                @default(false)
  token                    String?                 @unique
}

enum Recurrence {
  NONE
  DAILY
  WEEKLY
  MONTHLY
  ANNUAL
}

// TODO: Delete ‚ùå
model EventSharedWithMember {
  eventId Int
  userId  Int
  event   Event @relation(fields: [eventId], references: [id])
  user    User  @relation(fields: [userId], references: [id])

  @@id([eventId, userId])
}

// TODO: Delete ‚ùå
model Meeting {
  id                       Int                     @id @default(autoincrement())
  title                    String
  description              String
  startDate                DateTime
  endDate                  DateTime
  isRecurring              Boolean?                @default(false)
  recurrence               Recurrence?             @default(NONE)
  location                 String
  place                    String?
  link                     String?
  createdAt                DateTime                @default(now())
  updatedAt                DateTime                @default(now()) @updatedAt
  userId                   Int
  user                     User                    @relation(fields: [userId], references: [id])
  notificationPreferenceId Int?
  notificationPreference   NotificationPreference? @relation(fields: [notificationPreferenceId], references: [id])
  notificationSent         Boolean?                @default(false)
  token                    String?                 @unique
}

// NOTE: OTHERS ############################################################################
model ResetToken {
  id              Int      @id @default(autoincrement())
  token           String
  validityEndDate DateTime
  userId          Int
  user            User     @relation(fields: [userId], references: [id])
}

//web and mobile tokens for the notifications
model DeviceToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  platform  String // Either 'web' or 'mobile'
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Invitation {
  id                         Int     @id @default(autoincrement())
  receiverId                 Int?
  senderId                   Int
  receiver                   User?   @relation("InvitationsReceived", fields: [receiverId], references: [id])
  sender                     User    @relation("InvitationsSent", fields: [senderId], references: [id])
  externalEmailInvitation    String?
  tokenForExternalInvitation String?
  isExternal                 Boolean @default(false)
  isRelation                 Boolean @default(false)
}

model AutoInstruction {
  id          Int      @id @default(autoincrement())
  description String
  order       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      Int
  user        User     @relation(fields: [userId], references: [id])
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String
  userId    Int
  noteId    Int
  user      User     @relation(fields: [userId], references: [id])
  note      Note     @relation("NoteComments", fields: [noteId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model SearchHistory {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  searchTerm String
  searchDate DateTime @default(now())
}

model Session {
  id        Int      @id @default(autoincrement())
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
}

model Meeting {
  id                       Int                     @id @default(autoincrement())
  title                    String
  description              String
  startDate                DateTime
  endDate                  DateTime
  isRecurring              Boolean?                @default(false)
  recurrence               Recurrence?             @default(NONE)
  location                 String
  place                    String?
  link                     String?
  createdAt                DateTime                @default(now())
  updatedAt                DateTime                @default(now()) @updatedAt
  userId                   Int
  user                     User                    @relation(fields: [userId], references: [id])
  notificationPreferenceId Int?
  notificationPreference   NotificationPreference? @relation(fields: [notificationPreferenceId], references: [id])
  notificationSent         Boolean?                @default(false)
  token                    String?                 @unique
  MeetingInvitation        MeetingInvitation[]
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REFUSED
}

model MeetingInvitation {
  id         Int              @id @default(autoincrement())
  senderId   Int
  receiverId Int
  meetingId  Int
  meeting    Meeting          @relation(fields: [meetingId], references: [id])
  receiver   User             @relation("MeetingInvitationsReceived", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User             @relation("MeetingInvitationsSent", fields: [senderId], references: [id], onDelete: Cascade)
  status     InvitationStatus @default(PENDING)
  updatedAt  DateTime         @default(now())
}

model NotificationPreference {
  id         Int                          @id @default(autoincrement())
  userId     Int                          @unique
  user       User                         @relation(fields: [userId], references: [id])
  types      NotificationPreferenceType[]
  timeBefore Int
  timeUnit   TimeUnit
  createdAt  DateTime                     @default(now())
  updatedAt  DateTime                     @default(now()) @updatedAt
  tasks      Task[]
  events     Event[]
  meetings   Meeting[]
}

model NotificationPreferenceType {
  id                       Int                    @id @default(autoincrement())
  type                     NotificationType
  notificationPreference   NotificationPreference @relation(fields: [notificationPreferenceId], references: [id], onDelete: Cascade)
  notificationPreferenceId Int
  createdAt                DateTime               @default(now())
  updatedAt                DateTime               @default(now()) @updatedAt
}

enum NotificationType {
  EMAIL
  PUSH
}

model Score {
  id        Int      @id @default(autoincrement())
  userId    Int
  time      Int
  level     Level
  createdAt DateTime @default(now())
  firstName String
  lastName  String
  user      User     @relation(fields: [userId], references: [id])
}

// feat (daily-tasks) >>>
model DailyPlan {
  id        Int      @id @default(autoincrement())
  /// La date correspondant √† la journ√©e qui vient d‚Äô√™tre cl√¥tur√©e
  date      DateTime @unique
  /// Flag indiquant que l‚Äôutilisateur a valid√© la fin de journ√©e et r√©alis√© sa planification
  confirmed Boolean  @default(false)
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model DailyTask {
  id            Int       @id @default(autoincrement())
  uniqueTaskId  String    @unique @default(uuid()) // <-- New field for unique task ID
  title         String
  description   String?
  scheduledDate DateTime
  originalDate  DateTime?
  carriedOver   Boolean   @default(false)
  order         Int
  priority      Int
  completed     Boolean   @default(false)
  completedAt   DateTime?
  userId        Int
  user          User      @relation(fields: [userId], references: [id])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
}

model DailyTaskHistory {
  id            Int       @id @default(autoincrement())
  uniqueTaskId  String    @unique // <-- We'll copy the uniqueTaskId from DailyTask when archiving
  title         String
  description   String?
  scheduledDate DateTime
  originalDate  DateTime?
  carriedOver   Boolean   @default(false)
  order         Int
  priority      Int
  completed     Boolean   @default(false)
  completedAt   DateTime?
  userId        Int
  archivedAt    DateTime  @default(now())
  createdAt     DateTime  @default(now())
  user          User      @relation(fields: [userId], references: [id])
}

// <<< feat (daily-tasks)
